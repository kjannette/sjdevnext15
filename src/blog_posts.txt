
—————————
Title:  Precision Prompting: Effective Coding with AI

Subtitle: Build a React login page in 3 minutes with 5 prompts

Date: 11/20/2025

Image: public/prompt_demo/prompt_demo_1.png

Image Caption:  After the first two prompts your login page should look like this.
 
Content: This is the first installment in an instructive series on prompt engineering.  

We’ll begin with a practical example, by building a common frontend component: a Javascript/React login page. 

Aside Start:

Note: for purposes of the below illustration, we assume that the project's necessary dependencies (i.e. React, React Router) are installed and the highest-order React component, the App (which renders all others), already exists.

Aside End:

Later posts in the series will explore backend services, tooling, scripting and will contrast/compare specific LLMs.  

## The Setup

First, some high-level considerations that you should always have in mind when composing prompts.

Prompts should be expressed  in, and seek to induce, step-by-step, chain of thought reasoning. Other key considerations:

1. Hierarchical structure is key.  Prompts should be composed top-down.  First think on the highest level, and deconstruct the task into discrete, bite-sized tasks. 

2. Precision is key. Prompts should encompass each step of a task as concisely as possible. 

3. Semantics are key. Segment prompts the way you separate concerns.  Think about it like architecture/design: Present an overview, then fine-grained segments addressing self-contained specs. Minimize overlap.

Organzied thoughts yield well structured, working code output. 

Start by asking yourself questions.  The answers will define the work.

What exactly **is** a  React  login page? **What does it do**, and what are **the minimal elements** it 
needs in order to do that? 

For illustrative purposes (we won’t get fancy yet), we’ll stick to the barest collection of elements needed to get credentialed users logged in.
users in done.

A login page **is** (at least):

1. A discrete React component.

2. Exported into a larger component hierarchy.

3. That imports a CSS file for (in this case, basic) styling.

4. That incorporates specific jsx DOM elements, such as, minimally:

    a. A header (<h1>) with a title, i.e. “Customer Login" or “Please enter username and password”.
    
    b. Form inputs for username and password.
    
    c. A submit button.

5. A login page **does certain tasks**, and therefore needs functions.

    a. A “handle submit” function, called when the submit button is clicked.
    
    b. A "validate" function, for the form input.
    
    c. An HTTP POST function (to send credentials to the backend for auth), process the response, take appropriate action:

        i. Navigate to the next page (if login is successful).

        ii. Navigate away from the page (i.e. if the user doesn't want to log in -- "onClick" function(s) ).

        iii. Handle errors on invalid input or unsuccessful login (credentials rejected, i.e. 401).

With clearly-defined requirements, we can now create a series of prompts. 

## The Execution

**Prompt 1 – Define the task and constraints**

Build a login page component for a React customer service application. In planning, examine the existing file structure.  The login page will be exported to, and incorporated in, the parent App component.

Requirements:

1. Use React functional components.

2. Style with plain CSS in a separate file, no CSS frameworks.

3. The login page will be a route in a React Router setup.

4. The login page will include a navigation bar at the top with a "home" link and a "login" link.  This should be a separate, reusable component that is imported.

5. The login page must also include:

    a. A placeholder header area at the top of the page.
    
    b. A simple form with two inputs: "User Name" and "Password".
    
    c. A "submit" button.

    d. A "validate" function for form input that accepts a standard email pattern (user@domain.com) username, and an 11 character password with at least one uppercase letter (A-Z) at least one number (0-9) and at least one special character (!@#$%^&()+-=[]{}|;:,.<>?) password.

    e. A POST function (just use fetch for now) to send the validated credentials to the backend.

    f. A function to navigate to the user dashboard we will build later if validation succeeds.

    e. A function to display an error message if validation fails (just a placeholder for now, we will build it out later.) 

First, think step-by-step and briefly describe: the architecture and file structure; then, hone in on requirements: imports, functions, a simple jsx UI design, and any other relevant implementation details. 

Finally, stop and wait for my confirmation or instructions before writing any code.

**This "pause and review" step is critical.** 

It prevents the AI from running ahead and making assumptions about what you want, gives you control over direction, and creates checkpoints where you can course-correct. 

Reviewing the output takes only seconds, but it's the difference between collaboration — where you guide the process iteratively — and delegation, where you hope the AI reads your mind. 

Aside Start:

**The most common source of "garbage" output is failure to guide the process and catch:**  

1. Incomplete Context Loading - When the LLM doesn't read ALL relevant files before starting, and works with assumptions.

2. Jumping to Solutions Too Quickly - LLMs pattern-match -- it's how they work -- but sometimes they do so without fully understanding YOUR specific configuration.  Therefore, LLMs might implement before validating assumptions against the actual codebase.

3. Not Verifying Changes - Ideally, LLMs should "proof read" sections after edits, but ensuring that happens is up to you.

4. Missing the Forest for the Trees - LLMs can get hyperfocused on code details, while neglecting structural realities.  This leads to absurd results, such as excessive, unnecessary (and expensive) API calls.

Aside End:

Observing a "pause and review" supervision cadence keeps the process on track. Treat the AI like a skilled, but overzealous, junior colleague: explain the plan, confirm understanding, then oversee execution details.  Beware of the LLM "getting away from" your intent.

—————————
Title:  Precision Prompting: Effective Coding with AI, Part 2

Subtitle: Second Installmant, Build a React login page in 3 minutes with 5 prompts

Content:  This is the second installment in a series on effective prompt engineering.  This prompt builds on the foundation created in the first one, above.  In it, we instructed  adding a second prompt to build what we defined with our LLM, above.

Date: Date: 11/25/2025

**Prompt 2 – Create basic component (no styling yet)**

That structure and approach is acceptable, keep it in mind as we move forward and make sure, as we build, our additions conform to it.  We will proceed with the plan in carefully executed phases.  The following instructions are for the second  phase - follow, but do not exceed them.

Think step-by-step and implement the components and functionality below, in the numbered order, explaining your plan concisely before writing each numbered item:

1. React Router functionality in the App component, which defines two routes:
    a. / for a basic "Home" page (we will build it later).
    b. /login for the new "Login" page.
2. The Login page component, containing:
    a. A placeholder header area.
    b. A form with: an input for "User Name", an input for "Password", and a submit button.
2. A separate Navbar component that is imported into the Login page and appears at the top, with navigation links to “Home” and “Login,” using React Router navigation.

Do not add any complex styling yet; keep JSX simple. Do not create functions for processing the form data input.  Pause after completion of the above steps for review and next instructions.

Give the output a quick inspection, just like a PR review and make corrections if needed, either manually or with brief follow-up prompts.

We will proceed with the implementation in the next post.